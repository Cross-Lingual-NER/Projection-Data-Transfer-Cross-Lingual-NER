"""This module contains proejetion transform that match
generated by CandidateExtractionTransform candidates with source
entities and then label raw target sentence."""

import logging
from itertools import combinations
from typing import Any, Iterable

import numpy as np
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import min_weight_full_bipartite_matching

from src.pipelines.candidates.evaluators import (
    get_entities_spans,
    get_relative_lenght_alignment_scores,
)
from src.pipelines.transforms_base import PipelineTransformBase

logger = logging.getLogger(__file__)


class BipartiteCandidatesMatchingProjectionTransform(PipelineTransformBase):
    """This class solves min weigh bipartite matching optimization problem to
    match candidates and source entities"""

    def __init__(
        self, input_orig_words_key: str, filter_entities_with_zero_cost: bool = True
    ) -> None:
        self.orig_key = input_orig_words_key
        self.filter_entities_with_zero_scores = filter_entities_with_zero_cost

    @staticmethod
    def remove_entities_with_zero_scores(
        scores: csr_matrix,
    ) -> tuple[csr_matrix, np.ndarray]:
        row_mask = scores.getnnz(1) > 0
        nnz_rows = np.argwhere(row_mask)[:, 0]
        scores = scores[row_mask]
        return scores, nnz_rows

    def __call__(self, input: Iterable[dict[str, Any]]) -> Iterable[dict[str, Any]]:
        for row in input:
            orig_words = row[self.orig_key]
            N_ORIG = len(orig_words)
            entities = row["entities"]
            alignments = row["word_alignments"]
            tgt_candidates = row["tgt_candidates"]

            labels = ["O"] * N_ORIG

            try:
                if len(entities) > 0:
                    src_ent_spans = get_entities_spans(entities)
                    scores = get_relative_lenght_alignment_scores(
                        alignments, src_ent_spans, tgt_candidates
                    )
                    if self.filter_entities_with_zero_scores:
                        scores, nnz_rows = self.remove_entities_with_zero_scores(scores)

                    row_ind, col_ind = min_weight_full_bipartite_matching(
                        scores, maximize=True
                    )

                    if self.filter_entities_with_zero_scores:
                        row_ind = nnz_rows[row_ind]

                    label_mask = np.zeros(N_ORIG, dtype=np.bool_)

                    for r, c in zip(row_ind, col_ind):
                        label = entities[r]["label"]
                        tgt_s, tgt_e = tgt_candidates[c]

                        if not np.any(label_mask[tgt_s:tgt_e]):
                            labels[tgt_s] = "B-" + label
                            for idx in range(tgt_s + 1, tgt_e):
                                labels[idx] = "I-" + label
                            label_mask[tgt_s:tgt_e] = True
            except Exception as e:
                logger.warning(
                    f"Failed entity-candidate matching for the input {row}. Reason: {e}"
                )

            row["labels"] = labels

            yield row


class ArgmaxCandidatesMatchingProjectionTransform(PipelineTransformBase):
    """This class apply argmax heuristic to match candidates and source entities.
    For every source entity it takes candidate with the highest matching score and
    remove from the list of candidate this candidate as well as all other that
    overlaps with it"""

    def __init__(self, input_orig_words_key: str) -> None:
        self.orig_key = input_orig_words_key

    @staticmethod
    def get_overlapped_by_candidates(
        tgt_candidates: list[tuple[int, int]]
    ) -> list[list[tuple[int, int]]]:
        max_pos = max(tgt_candidates, key=lambda span: span[1])[1]

        overlapped = [set() for _ in range(len(tgt_candidates))]
        # for every position store all candidates thah hit it
        pos_hit_list = [[] for _ in range(max_pos)]

        for cand_idx, (start_idx, end_idx) in enumerate(tgt_candidates):
            for i in range(start_idx, end_idx):
                pos_hit_list[i].append(cand_idx)

        for pos_hits in pos_hit_list:
            if len(pos_hits) > 1:  # several cand hit this position
                for a, b in combinations(pos_hits, 2):
                    overlapped[a].add(b)
                    overlapped[b].add(a)

        return [list(s) for s in overlapped]

    @staticmethod
    def match_source_entities(
        scores: csr_matrix, tgt_candidates: list[tuple[int, int]]
    ) -> tuple[list[int], list[int]]:
        n_ent, n_cand = scores.shape
        if n_ent == 0 or n_cand == 0:
            return [], []

        C = scores.toarray()

        overlapped_by_cands = (
            ArgmaxCandidatesMatchingProjectionTransform.get_overlapped_by_candidates(
                tgt_candidates
            )
        )

        src_idxs, cand_idxs = [], []
        while C.max() > 0:
            # take item with maximum cost and add it to solution
            ent_idx, cand_idx = np.unravel_index(
                np.argmax(C.reshape(1, -1)), (n_ent, n_cand)
            )
            src_idxs.append(ent_idx.item())
            cand_idxs.append(cand_idx.item())

            # entity reach projection limit (n <= 1)
            C[ent_idx] = 0

            # remove overlapped candidates from possible solution
            overlapped = overlapped_by_cands[cand_idx]
            overlapped.append(cand_idx)
            C[:, overlapped] = 0

        return src_idxs, cand_idxs

    def __call__(self, input: Iterable[dict[str, Any]]) -> Iterable[dict[str, Any]]:
        for row in input:
            orig_words = row[self.orig_key]
            entities = row["entities"]
            alignments = row["word_alignments"]
            tgt_candidates = row["tgt_candidates"]

            labels = ["O"] * len(orig_words)

            try:
                if len(entities) > 0:
                    src_ent_spans = get_entities_spans(entities)
                    scores = get_relative_lenght_alignment_scores(
                        alignments, src_ent_spans, tgt_candidates
                    )

                    row_ind, col_ind = self.match_source_entities(
                        scores, tgt_candidates
                    )

                    for r, c in zip(row_ind, col_ind):
                        label = entities[r]["label"]
                        tgt_s, tgt_e = tgt_candidates[c]

                        labels[tgt_s] = "B-" + label
                        for idx in range(tgt_s + 1, tgt_e):
                            labels[idx] = "I-" + label
            except Exception as e:
                logger.warn(
                    f"Failed entity-candidate matching for the input {row}. Reason: {e}"
                )

            row["labels"] = labels

            yield row
